import numpy as np
import torch
from shapely.geometry import Point, Polygon
from trajdata.utils import map_utils

from blg.utils.general_helpers import CPU


class OccupancyGraph(object):
    def __init__(self, center, left_edge, right_edge):
        self.center = center
        # N of polygons for left edge and right edge
        self.left_edge = left_edge
        self.right_edge = right_edge

    def proj_traj_to_node(self, beh_traj):
        """Project the behavior trajectory to lane graph nodes.
        This function can be used for trajectories generated by other agents.

        Args:
            beh_traj (tensor): [M, T, 4], trajectories generated by behavior model.
                M is the number of behaviors, T is the number of time steps, 4 is the x, y, heading, velocity.

        Returns:
            occ_graph_beh_node (numpy.arrary): [M, T, N]. 0 means the node is not occupied, 1 means occupied.
                M is the number of behaviors, T is the number of time steps, N is the number of nodes.
        """

        M, T, _ = beh_traj.shape
        occ_graph_beh_node = np.zeros((M, T, len(self.left_edge)))  # [M, T, N]
        for n_i in range(len(self.left_edge)):
            left_i = CPU(self.left_edge[n_i])
            right_i = CPU(self.right_edge[n_i])
            edges = np.concatenate((left_i, right_i[::-1]), axis=0)[:, 0:2]
            polygon = Polygon(edges)

            # check if the any point of the trajectory is inside the polygon
            for b_i in range(len(beh_traj)):
                one_beh_traj = beh_traj[b_i].cpu().numpy()  # [T, 4]
                for t_i in range(len(one_beh_traj)):
                    point = Point(one_beh_traj[t_i, 0:2])
                    if point.within(polygon):
                        occ_graph_beh_node[b_i, t_i, n_i] = 1
                        break
        return occ_graph_beh_node

    @staticmethod
    def check_collision(beh_node1, beh_node2):
        """Check if two behaviors are in collision.

        Args:
            beh_node1 (numpy.array): [M1, T, N], 0 means the node is not occupied, 1 means occupied.
            beh_node2 (numpy.array): [M2, T, N], 0 means the node is not occupied, 1 means occupied.

        Returns:
            collision (numpy.arrary): [M1, M2], which behavior is in collision with which behavior.
        """
        # print(beh_node1.shape)
        # print(beh_node2.shape)

        # print(beh_node1[3])
        # print(beh_node2[1])
        
        # [M1, T, N] -> [M1, 1, T, N]
        beh_node1 = beh_node1[:, None]
        # [M2, T, N] -> [1, M2, T, N]
        beh_node2 = beh_node2[None]
        

        overlap = np.logical_and(beh_node1, beh_node2)  # [M1, M2, T, N]
        overlap = overlap.sum(axis=3)  # [M1, M2, T]
        collision = np.any(overlap > 0, axis=2)  # [M1, M2]
        return collision


class OccupancyModel(object):
    """The model maintain the occupancy graph with nodes, which represent the lane center and edges."""

    def __init__(self, interval, threshold=1.0):
        self.interval = interval  # the length of each node polygon
        self.threshold = threshold  # the threshold to filter out the close points

    def _get_closest_edge_pts(self, edge, center, num_pts):
        """Get the left or right edge points that are closest to the center points."""
        # [N, M]
        dist = torch.norm(center[:, None, 0:2] - edge[None, :, 0:2], dim=-1)
        close_idx = torch.argmin(dist, dim=1)  # [N]

        if len(close_idx) == 1:
            # there is only one center node, we mannually create the  end index
            start_idx = [close_idx[0]]
            end_idx = [close_idx[0] + num_pts]
        else:
            start_idx = close_idx[:-1].clone()
            end_idx = close_idx[1:].clone()

        edge_list = []
        for s, e in zip(start_idx, end_idx):
            if s >= e:
                # print("Concer cases: start index is greater than end index")
                e = s + num_pts
            seg = map_utils.interpolate(CPU(edge[s:e]), num_pts=num_pts)
            edge_list.append(seg)

        edge_list = np.stack(edge_list, axis=0)  # [N, M, 2]
        edge_list = torch.tensor(edge_list, device=center.device).float()
        return edge_list

    def _build_occ_node(self, center, left_edge, right_edge, interval):
        pairwise_dist = torch.norm(center[1:, 0:2] - center[:-1, 0:2], dim=1)

        # we assume the interval is equal for all the points
        total_len = torch.sum(pairwise_dist).item()
        avg_len = total_len / len(center)

        idx_inter = int(interval / avg_len)
        assert idx_inter > 0, "num_points should be greater than 0"
        center = center[::idx_inter].clone()  # [N, 2]

        left_edge = self._get_closest_edge_pts(left_edge, center, num_pts=idx_inter)
        right_edge = self._get_closest_edge_pts(right_edge, center, num_pts=idx_inter)
        center = center[:-1]  # remove the last point
        return center, left_edge, right_edge

    def _filter_close_pts(self, existing_pts, new_pt, left_edge, right_edge, threshold):
        # maybe we should merge close points rather than filter them out
        if len(existing_pts) == 0:
            left_edge = left_edge.unbind(dim=0)  # [N, M, 2] -> N * [M, 2]
            right_edge = right_edge.unbind(dim=0)
            return new_pt, left_edge, right_edge
        existing_pts = torch.cat(existing_pts, dim=0)

        # [N, 1, 2] + [1, M, 2] -> [N, M]
        dist = torch.norm(new_pt[:, None, 0:2] - existing_pts[None, :, 0:2], dim=-1)
        dist_mask = dist < threshold
        valid_mask = torch.sum(dist_mask, dim=1) == 0

        new_pt = new_pt[valid_mask]
        left_edge = left_edge[valid_mask].unbind(dim=0)
        right_edge = right_edge[valid_mask].unbind(dim=0)
        return new_pt, left_edge, right_edge

    def _collect_node(self, lane_tree, center_list, left_edge_list, right_edge_list):
        for c_i in range(len(lane_tree.center)):
            center = lane_tree.center[c_i]
            left_edge = lane_tree.left_edge[c_i]
            right_edge = lane_tree.right_edge[c_i]
            center, left_edge, right_edge = self._build_occ_node(
                center, left_edge, right_edge, interval=self.interval
            )
            center, left_edge, right_edge = self._filter_close_pts(
                center_list, center, left_edge, right_edge, self.threshold
            )
            center_list.append(center)
            left_edge_list += left_edge
            right_edge_list += right_edge

    def get_occ_graph(self, lane_graph):
        """generate occupancy graph from lane graph.

        Args:
            lane_graph (LaneGraph): the lane graph

        Returns:
            center_list (List): list of nodes center
            left_edge_list (List): list of left edges
            right_edge_list (List): list of right edges
        """

        # initialize the occupancy graph
        center_list = []
        left_edge_list = []
        right_edge_list = []

        # collect the nodes from the current lane
        self._collect_node(
            lane_graph.curr, center_list, left_edge_list, right_edge_list
        )

        # collect the nodes from the left and right lanes
        for l_i in range(len(lane_graph.left_group)):
            lane_left = lane_graph.left_group[l_i]
            self._collect_node(lane_left, center_list, left_edge_list, right_edge_list)

        # collect the nodes from the left and right lanes
        for r_i in range(len(lane_graph.right_group)):
            lane_right = lane_graph.right_group[r_i]
            self._collect_node(lane_right, center_list, left_edge_list, right_edge_list)

        center_list = np.concatenate(center_list, axis=0)
        return OccupancyGraph(center_list, left_edge_list, right_edge_list)
